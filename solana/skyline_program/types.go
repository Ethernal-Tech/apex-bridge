// Code generated by https://github.com/gagliardetto/anchor-go. DO NOT EDIT.
// This file contains parsers for the types defined in the IDL.

package skyline_program

import (
	"bytes"
	"fmt"
	errors "github.com/gagliardetto/anchor-go/errors"
	binary "github.com/gagliardetto/binary"
	solanago "github.com/gagliardetto/solana-go"
)

// Event emitted when a bridge request is created.
//
// This event is emitted when a user initiates a cross-chain token transfer.
// The event contains all the information needed for validators to process
// the request and execute the corresponding transaction on the destination chain.
type BridgeRequestEvent struct {
	// Public key of the user who initiated the bridge request
	Sender solanago.PublicKey `json:"sender"`

	// Amount of tokens to be bridged to the destination chain
	Amount uint64 `json:"amount"`

	// Receiver's address on the destination chain (variable length byte vector)
	// This format accommodates various address formats across different blockchains
	Receiver []byte `json:"receiver"`

	// Chain ID identifying the destination blockchain network
	DestinationChain uint8 `json:"destinationChain"`

	// Public key of the token mint being bridged
	MintToken solanago.PublicKey `json:"mintToken"`

	// The batch request ID associated with this bridge request
	BatchRequestId uint64 `json:"batchRequestId"`
}

func (obj BridgeRequestEvent) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Sender`:
	err = encoder.Encode(obj.Sender)
	if err != nil {
		return errors.NewField("Sender", err)
	}
	// Serialize `Amount`:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Serialize `Receiver`:
	err = encoder.Encode(obj.Receiver)
	if err != nil {
		return errors.NewField("Receiver", err)
	}
	// Serialize `DestinationChain`:
	err = encoder.Encode(obj.DestinationChain)
	if err != nil {
		return errors.NewField("DestinationChain", err)
	}
	// Serialize `MintToken`:
	err = encoder.Encode(obj.MintToken)
	if err != nil {
		return errors.NewField("MintToken", err)
	}
	// Serialize `BatchRequestId`:
	err = encoder.Encode(obj.BatchRequestId)
	if err != nil {
		return errors.NewField("BatchRequestId", err)
	}
	return nil
}

func (obj BridgeRequestEvent) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding BridgeRequestEvent: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *BridgeRequestEvent) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Sender`:
	err = decoder.Decode(&obj.Sender)
	if err != nil {
		return errors.NewField("Sender", err)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Deserialize `Receiver`:
	err = decoder.Decode(&obj.Receiver)
	if err != nil {
		return errors.NewField("Receiver", err)
	}
	// Deserialize `DestinationChain`:
	err = decoder.Decode(&obj.DestinationChain)
	if err != nil {
		return errors.NewField("DestinationChain", err)
	}
	// Deserialize `MintToken`:
	err = decoder.Decode(&obj.MintToken)
	if err != nil {
		return errors.NewField("MintToken", err)
	}
	// Deserialize `BatchRequestId`:
	err = decoder.Decode(&obj.BatchRequestId)
	if err != nil {
		return errors.NewField("BatchRequestId", err)
	}
	return nil
}

func (obj *BridgeRequestEvent) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling BridgeRequestEvent: %w", err)
	}
	return nil
}

func UnmarshalBridgeRequestEvent(buf []byte) (*BridgeRequestEvent, error) {
	obj := new(BridgeRequestEvent)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Represents a bridging transaction that transfers tokens to a recipient.
//
// The `BridgingTransaction` account tracks a pending token transfer that requires
// validator consensus. Once enough validators have approved the transaction (meeting
// the threshold), the tokens are automatically transferred or minted to the recipient,
// and the account is closed.
//
// # Fields
//
// * `id` - Unique identifier for the transaction (same as the account's key)
// * `amount` - The amount of tokens to transfer to the recipient
// * `receiver` - The public key of the recipient on the destination chain
// * `mint_token` - The public key of the token mint being bridged
// * `signers` - List of validator public keys that have approved this transaction
// * `bump` - Bump seed for the PDA derivation
// * `batch_id` - The batch ID of this transaction (must be greater than last_batch_id)
type BridgingTransaction struct {
	// Unique identifier for the transaction
	Id solanago.PublicKey `json:"id"`

	// The amount of tokens to transfer to the recipient
	Amount uint64 `json:"amount"`

	// The public key of the recipient on the destination chain
	Receiver solanago.PublicKey `json:"receiver"`

	// The public key of the token mint being bridged
	MintToken solanago.PublicKey `json:"mintToken"`

	// List of validator public keys that have approved this transaction
	Signers []solanago.PublicKey `json:"signers"`

	// Bump seed for the Program Derived Address (PDA)
	Bump uint8 `json:"bump"`

	// The batch ID of this transaction (must be greater than last_batch_id)
	BatchId uint64 `json:"batchId"`
}

func (obj BridgingTransaction) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Id`:
	err = encoder.Encode(obj.Id)
	if err != nil {
		return errors.NewField("Id", err)
	}
	// Serialize `Amount`:
	err = encoder.Encode(obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Serialize `Receiver`:
	err = encoder.Encode(obj.Receiver)
	if err != nil {
		return errors.NewField("Receiver", err)
	}
	// Serialize `MintToken`:
	err = encoder.Encode(obj.MintToken)
	if err != nil {
		return errors.NewField("MintToken", err)
	}
	// Serialize `Signers`:
	err = encoder.Encode(obj.Signers)
	if err != nil {
		return errors.NewField("Signers", err)
	}
	// Serialize `Bump`:
	err = encoder.Encode(obj.Bump)
	if err != nil {
		return errors.NewField("Bump", err)
	}
	// Serialize `BatchId`:
	err = encoder.Encode(obj.BatchId)
	if err != nil {
		return errors.NewField("BatchId", err)
	}
	return nil
}

func (obj BridgingTransaction) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding BridgingTransaction: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *BridgingTransaction) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Id`:
	err = decoder.Decode(&obj.Id)
	if err != nil {
		return errors.NewField("Id", err)
	}
	// Deserialize `Amount`:
	err = decoder.Decode(&obj.Amount)
	if err != nil {
		return errors.NewField("Amount", err)
	}
	// Deserialize `Receiver`:
	err = decoder.Decode(&obj.Receiver)
	if err != nil {
		return errors.NewField("Receiver", err)
	}
	// Deserialize `MintToken`:
	err = decoder.Decode(&obj.MintToken)
	if err != nil {
		return errors.NewField("MintToken", err)
	}
	// Deserialize `Signers`:
	err = decoder.Decode(&obj.Signers)
	if err != nil {
		return errors.NewField("Signers", err)
	}
	// Deserialize `Bump`:
	err = decoder.Decode(&obj.Bump)
	if err != nil {
		return errors.NewField("Bump", err)
	}
	// Deserialize `BatchId`:
	err = decoder.Decode(&obj.BatchId)
	if err != nil {
		return errors.NewField("BatchId", err)
	}
	return nil
}

func (obj *BridgingTransaction) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling BridgingTransaction: %w", err)
	}
	return nil
}

func UnmarshalBridgingTransaction(buf []byte) (*BridgingTransaction, error) {
	obj := new(BridgingTransaction)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Event emitted when a bridging transaction is successfully executed.
//
// This event is emitted after a bridging transaction has received sufficient
// validator approvals and the tokens have been transferred or minted to the recipient.
type TransactionExecutedEvent struct {
	// The unique identifier of the transaction that was executed
	TransactionId solanago.PublicKey `json:"transactionId"`

	// The batch ID of the executed transaction
	BatchId uint64 `json:"batchId"`
}

func (obj TransactionExecutedEvent) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `TransactionId`:
	err = encoder.Encode(obj.TransactionId)
	if err != nil {
		return errors.NewField("TransactionId", err)
	}
	// Serialize `BatchId`:
	err = encoder.Encode(obj.BatchId)
	if err != nil {
		return errors.NewField("BatchId", err)
	}
	return nil
}

func (obj TransactionExecutedEvent) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding TransactionExecutedEvent: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *TransactionExecutedEvent) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `TransactionId`:
	err = decoder.Decode(&obj.TransactionId)
	if err != nil {
		return errors.NewField("TransactionId", err)
	}
	// Deserialize `BatchId`:
	err = decoder.Decode(&obj.BatchId)
	if err != nil {
		return errors.NewField("BatchId", err)
	}
	return nil
}

func (obj *TransactionExecutedEvent) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling TransactionExecutedEvent: %w", err)
	}
	return nil
}

func UnmarshalTransactionExecutedEvent(buf []byte) (*TransactionExecutedEvent, error) {
	obj := new(TransactionExecutedEvent)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Represents a pending validator set update that requires consensus.
//
// The `ValidatorDelta` account tracks a proposed change to the validator set that
// requires approval from the current validators. Once enough validators have approved
// the proposal (meeting the threshold), the changes are applied to the validator set,
// and the account is closed.
//
// # Fields
//
// * `id` - Unique identifier for the validator set change (same as the account's key)
// * `added` - List of new validator public keys to add to the validator set
// * `removed` - List of validator indices to remove from the validator set
// * `bump` - Bump seed for the PDA derivation
// * `batch_id` - The batch ID of this validator set change (must be greater than last_batch_id)
// * `signers` - List of validator public keys that have approved this change
// * `proposal_hash` - Hash of the proposal to ensure all validators approve the same change
type ValidatorDelta struct {
	// Unique identifier for the validator set change
	Id solanago.PublicKey `json:"id"`

	// List of new validator public keys to add (max 10 per change)
	Added []solanago.PublicKey `json:"added"`

	// List of validator public keys to remove (max 10 per change)
	Removed []solanago.PublicKey `json:"removed"`

	// Bump seed for the Program Derived Address (PDA)
	Bump uint8 `json:"bump"`

	// The batch ID of this validator set change (must be greater than last_batch_id)
	BatchId uint64 `json:"batchId"`

	// List of validator public keys that have approved this change
	Signers []solanago.PublicKey `json:"signers"`

	// Hash of the proposal to ensure all validators approve the same change
	ProposalHash [32]uint8 `json:"proposalHash"`
}

func (obj ValidatorDelta) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Id`:
	err = encoder.Encode(obj.Id)
	if err != nil {
		return errors.NewField("Id", err)
	}
	// Serialize `Added`:
	err = encoder.Encode(obj.Added)
	if err != nil {
		return errors.NewField("Added", err)
	}
	// Serialize `Removed`:
	err = encoder.Encode(obj.Removed)
	if err != nil {
		return errors.NewField("Removed", err)
	}
	// Serialize `Bump`:
	err = encoder.Encode(obj.Bump)
	if err != nil {
		return errors.NewField("Bump", err)
	}
	// Serialize `BatchId`:
	err = encoder.Encode(obj.BatchId)
	if err != nil {
		return errors.NewField("BatchId", err)
	}
	// Serialize `Signers`:
	err = encoder.Encode(obj.Signers)
	if err != nil {
		return errors.NewField("Signers", err)
	}
	// Serialize `ProposalHash`:
	err = encoder.Encode(obj.ProposalHash)
	if err != nil {
		return errors.NewField("ProposalHash", err)
	}
	return nil
}

func (obj ValidatorDelta) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ValidatorDelta: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ValidatorDelta) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Id`:
	err = decoder.Decode(&obj.Id)
	if err != nil {
		return errors.NewField("Id", err)
	}
	// Deserialize `Added`:
	err = decoder.Decode(&obj.Added)
	if err != nil {
		return errors.NewField("Added", err)
	}
	// Deserialize `Removed`:
	err = decoder.Decode(&obj.Removed)
	if err != nil {
		return errors.NewField("Removed", err)
	}
	// Deserialize `Bump`:
	err = decoder.Decode(&obj.Bump)
	if err != nil {
		return errors.NewField("Bump", err)
	}
	// Deserialize `BatchId`:
	err = decoder.Decode(&obj.BatchId)
	if err != nil {
		return errors.NewField("BatchId", err)
	}
	// Deserialize `Signers`:
	err = decoder.Decode(&obj.Signers)
	if err != nil {
		return errors.NewField("Signers", err)
	}
	// Deserialize `ProposalHash`:
	err = decoder.Decode(&obj.ProposalHash)
	if err != nil {
		return errors.NewField("ProposalHash", err)
	}
	return nil
}

func (obj *ValidatorDelta) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ValidatorDelta: %w", err)
	}
	return nil
}

func UnmarshalValidatorDelta(buf []byte) (*ValidatorDelta, error) {
	obj := new(ValidatorDelta)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Represents the validator set that controls bridge operations.
//
// The `ValidatorSet` account stores the list of validators authorized to perform
// critical bridge operations and the consensus threshold required for approval.
// This account is initialized once and can be updated through the validator set
// change instruction with proper consensus.
//
// # Fields
//
// * `signers` - Vector of validator public keys (max 128 validators)
// * `threshold` - Number of signatures required for consensus (automatically calculated)
// * `bump` - Bump seed for the PDA derivation
// * `last_batch_id` - The last processed batch ID to prevent replay attacks
// * `bridge_request_count` - Total count of bridge requests processed
type ValidatorSet struct {
	// List of validator public keys that can sign bridge operations
	// Maximum length is constrained by `MAX_VALIDATORS` constant
	Signers []solanago.PublicKey `json:"signers"`

	// Consensus threshold - number of validator signatures required
	// Automatically calculated using the formula: num_signers - floor((num_signers - 1) / 3)
	Threshold uint8 `json:"threshold"`

	// Bump seed for the Program Derived Address (PDA)
	Bump uint8 `json:"bump"`

	// Last batch ID processed to prevent replay attacks and ensure sequential processing
	LastBatchId uint64 `json:"lastBatchId"`

	// Total count of bridge requests processed since initialization
	BridgeRequestCount uint64 `json:"bridgeRequestCount"`
}

func (obj ValidatorSet) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Signers`:
	err = encoder.Encode(obj.Signers)
	if err != nil {
		return errors.NewField("Signers", err)
	}
	// Serialize `Threshold`:
	err = encoder.Encode(obj.Threshold)
	if err != nil {
		return errors.NewField("Threshold", err)
	}
	// Serialize `Bump`:
	err = encoder.Encode(obj.Bump)
	if err != nil {
		return errors.NewField("Bump", err)
	}
	// Serialize `LastBatchId`:
	err = encoder.Encode(obj.LastBatchId)
	if err != nil {
		return errors.NewField("LastBatchId", err)
	}
	// Serialize `BridgeRequestCount`:
	err = encoder.Encode(obj.BridgeRequestCount)
	if err != nil {
		return errors.NewField("BridgeRequestCount", err)
	}
	return nil
}

func (obj ValidatorSet) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ValidatorSet: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ValidatorSet) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Signers`:
	err = decoder.Decode(&obj.Signers)
	if err != nil {
		return errors.NewField("Signers", err)
	}
	// Deserialize `Threshold`:
	err = decoder.Decode(&obj.Threshold)
	if err != nil {
		return errors.NewField("Threshold", err)
	}
	// Deserialize `Bump`:
	err = decoder.Decode(&obj.Bump)
	if err != nil {
		return errors.NewField("Bump", err)
	}
	// Deserialize `LastBatchId`:
	err = decoder.Decode(&obj.LastBatchId)
	if err != nil {
		return errors.NewField("LastBatchId", err)
	}
	// Deserialize `BridgeRequestCount`:
	err = decoder.Decode(&obj.BridgeRequestCount)
	if err != nil {
		return errors.NewField("BridgeRequestCount", err)
	}
	return nil
}

func (obj *ValidatorSet) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ValidatorSet: %w", err)
	}
	return nil
}

func UnmarshalValidatorSet(buf []byte) (*ValidatorSet, error) {
	obj := new(ValidatorSet)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Event emitted when the validator set is successfully updated.
//
// This event is emitted after a validator set change proposal has received
// sufficient validator approvals and the changes have been applied to the validator set.
type ValidatorSetUpdatedEvent struct {
	// The new list of validator signers after the update
	NewSigners []solanago.PublicKey `json:"newSigners"`

	// The new consensus threshold for the validator set
	NewThreshold uint8 `json:"newThreshold"`

	// The batch ID associated with the validator set update
	BatchId uint64 `json:"batchId"`
}

func (obj ValidatorSetUpdatedEvent) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `NewSigners`:
	err = encoder.Encode(obj.NewSigners)
	if err != nil {
		return errors.NewField("NewSigners", err)
	}
	// Serialize `NewThreshold`:
	err = encoder.Encode(obj.NewThreshold)
	if err != nil {
		return errors.NewField("NewThreshold", err)
	}
	// Serialize `BatchId`:
	err = encoder.Encode(obj.BatchId)
	if err != nil {
		return errors.NewField("BatchId", err)
	}
	return nil
}

func (obj ValidatorSetUpdatedEvent) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding ValidatorSetUpdatedEvent: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *ValidatorSetUpdatedEvent) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `NewSigners`:
	err = decoder.Decode(&obj.NewSigners)
	if err != nil {
		return errors.NewField("NewSigners", err)
	}
	// Deserialize `NewThreshold`:
	err = decoder.Decode(&obj.NewThreshold)
	if err != nil {
		return errors.NewField("NewThreshold", err)
	}
	// Deserialize `BatchId`:
	err = decoder.Decode(&obj.BatchId)
	if err != nil {
		return errors.NewField("BatchId", err)
	}
	return nil
}

func (obj *ValidatorSetUpdatedEvent) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling ValidatorSetUpdatedEvent: %w", err)
	}
	return nil
}

func UnmarshalValidatorSetUpdatedEvent(buf []byte) (*ValidatorSetUpdatedEvent, error) {
	obj := new(ValidatorSetUpdatedEvent)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}

// Represents the vault account that holds bridged tokens.
//
// The `Vault` account is a Program Derived Address (PDA) that serves as the authority
// for token operations. It can be set as the mint authority for tokens, allowing it to
// mint tokens on the destination chain, or it can hold tokens in an associated token
// account for transfer operations.
//
// # Fields
//
// * `address` - The public key of the vault account (same as the account's key)
// * `bump` - Bump seed for the PDA derivation
type Vault struct {
	// Bump seed for the Program Derived Address (PDA)
	Bump uint8 `json:"bump"`
}

func (obj Vault) MarshalWithEncoder(encoder *binary.Encoder) (err error) {
	// Serialize `Bump`:
	err = encoder.Encode(obj.Bump)
	if err != nil {
		return errors.NewField("Bump", err)
	}
	return nil
}

func (obj Vault) Marshal() ([]byte, error) {
	buf := bytes.NewBuffer(nil)
	encoder := binary.NewBorshEncoder(buf)
	err := obj.MarshalWithEncoder(encoder)
	if err != nil {
		return nil, fmt.Errorf("error while encoding Vault: %w", err)
	}
	return buf.Bytes(), nil
}

func (obj *Vault) UnmarshalWithDecoder(decoder *binary.Decoder) (err error) {
	// Deserialize `Bump`:
	err = decoder.Decode(&obj.Bump)
	if err != nil {
		return errors.NewField("Bump", err)
	}
	return nil
}

func (obj *Vault) Unmarshal(buf []byte) error {
	err := obj.UnmarshalWithDecoder(binary.NewBorshDecoder(buf))
	if err != nil {
		return fmt.Errorf("error while unmarshaling Vault: %w", err)
	}
	return nil
}

func UnmarshalVault(buf []byte) (*Vault, error) {
	obj := new(Vault)
	err := obj.Unmarshal(buf)
	if err != nil {
		return nil, err
	}
	return obj, nil
}
